/*
* jQuery File Upload User Interface Plugin 6.7
* https://github.com/blueimp/jQuery-File-Upload
*
* Copyright 2010, Sebastian Tschan
* https://blueimp.net
*
* Licensed under the MIT license:
* http://www.opensource.org/licenses/MIT
*/

// The Templates plugin is included to render the upload/download listings
(function (a) { "use strict"; var b = function (a, c) { var d = /[^\w\-\.:]/.test(a) ? new Function(b.arg + ",tmpl", "var _e=tmpl.encode" + b.helper + ",_s='" + a.replace(b.regexp, b.func) + "';return _s;") : b.cache[a] = b.cache[a] || b(b.load(a)); return c ? d(c, b) : function (a) { return d(a, b) } }; b.cache = {}, b.load = function (a) { return document.getElementById(a).innerHTML }, b.regexp = /([\s'\\])(?![^%]*%\})|(?:\{%(=|#)([\s\S]+?)%\})|(\{%)|(%\})/g, b.func = function (a, b, c, d, e, f) { if (b) return { "\n": "\\n", "\r": "\\r", "\t": "\\t", " ": " "}[a] || "\\" + a; if (c) return c === "=" ? "'+_e(" + d + ")+'" : "'+(" + d + "||'')+'"; if (e) return "';"; if (f) return "_s+='" }, b.encReg = /[<>&"'\x00]/g, b.encMap = { "<": "&lt;", ">": "&gt;", "&": "&amp;", '"': "&quot;", "'": "&#39;" }, b.encode = function (a) { return String(a || "").replace(b.encReg, function (a) { return b.encMap[a] || "" }) }, b.arg = "o", b.helper = ",print=function(s,e){_s+=e&&(s||'')||_e(s);},include=function(s,d){_s+=tmpl(s,d);}", typeof define == "function" && define.amd ? define(function () { return b }) : a.tmpl = b })(this);
// The Load Image plugin is included for the preview images and image resizing functionality
(function (a) { "use strict"; var b = function (a, c, d) { var e = document.createElement("img"), f, g; return e.onerror = c, e.onload = function () { g && b.revokeObjectURL(g), c(b.scale(e, d)) }, window.Blob && a instanceof Blob || window.File && a instanceof File ? f = g = b.createObjectURL(a) : f = a, f ? (e.src = f, e) : b.readFile(a, function (a) { e.src = a }) }, c = window.createObjectURL && window || window.URL && URL || window.webkitURL && webkitURL; b.scale = function (a, b) { b = b || {}; var c = document.createElement("canvas"), d = a.width, e = a.height, f = Math.max((b.minWidth || d) / d, (b.minHeight || e) / e); return f > 1 && (d = parseInt(d * f, 10), e = parseInt(e * f, 10)), f = Math.min((b.maxWidth || d) / d, (b.maxHeight || e) / e), f < 1 && (d = parseInt(d * f, 10), e = parseInt(e * f, 10)), a.getContext || b.canvas && c.getContext ? (c.width = d, c.height = e, c.getContext("2d").drawImage(a, 0, 0, d, e), c) : (a.width = d, a.height = e, a) }, b.createObjectURL = function (a) { return c ? c.createObjectURL(a) : !1 }, b.revokeObjectURL = function (a) { return c ? c.revokeObjectURL(a) : !1 }, b.readFile = function (a, b) { if (window.FileReader && FileReader.prototype.readAsDataURL) { var c = new FileReader; return c.onload = function (a) { b(a.target.result) }, c.readAsDataURL(a), c } return !1 }, typeof define != "undefined" && define.amd ? define(function () { return b }) : a.loadImage = b })(this);
// The Canvas to Blob plugin is included for image resizing functionality 
(function (a) { "use strict"; var b = a.HTMLCanvasElement && a.HTMLCanvasElement.prototype, c = a.BlobBuilder || a.WebKitBlobBuilder || a.MozBlobBuilder, d = c && a.atob && a.ArrayBuffer && a.Uint8Array && function (a) { var b, d, e, f, g, h; a.split(",")[0].indexOf("base64") >= 0 ? b = atob(a.split(",")[1]) : b = decodeURIComponent(a.split(",")[1]), d = new ArrayBuffer(b.length), e = new Uint8Array(d); for (f = 0; f < b.length; f += 1) e[f] = b.charCodeAt(f); return g = new c, g.append(d), h = a.split(",")[0].split(":")[1].split(";")[0], g.getBlob(h) }; a.HTMLCanvasElement && !b.toBlob && (b.mozGetAsFile ? b.toBlob = function (a, b) { a(this.mozGetAsFile("blob", b)) } : b.toDataURL && d && (b.toBlob = function (a, b) { a(d(this.toDataURL(b))) })), typeof define != "undefined" && define.amd ? define(function () { return d }) : a.dataURLtoBlob = d })(this);
// The Iframe Transport is required for browsers without support for XHR file uploads
(function (factory) { if (typeof define === "function" && define.amd) { define(["jquery"], factory) } else { factory(window.jQuery) } } (function ($) { var counter = 0; $.ajaxTransport("iframe", function (options) { if (options.async && (options.type === "POST" || options.type === "GET")) { var form, iframe; return { send: function (_, completeCallback) { form = $('<form style="display:none;"></form>'); iframe = $('<iframe src="javascript:false;" name="iframe-transport-' + (counter += 1) + '"></iframe>').bind("load", function () { var fileInputClones, paramNames = $.isArray(options.paramName) ? options.paramName : [options.paramName]; iframe.unbind("load").bind("load", function () { var response; try { response = iframe.contents(); if (!response.length || !response[0].firstChild) { throw new Error() } } catch (e) { response = undefined } completeCallback(200, "success", { iframe: response }); $('<iframe src="javascript:false;"></iframe>').appendTo(form); form.remove() }); form.prop("target", iframe.prop("name")).prop("action", options.url).prop("method", options.type); if (options.formData) { $.each(options.formData, function (index, field) { $('<input type="hidden"/>').prop("name", field.name).val(field.value).appendTo(form) }) } if (options.fileInput && options.fileInput.length && options.type === "POST") { fileInputClones = options.fileInput.clone(); options.fileInput.after(function (index) { return fileInputClones[index] }); if (options.paramName) { options.fileInput.each(function (index) { $(this).prop("name", paramNames[index] || options.paramName) }) } form.append(options.fileInput).prop("enctype", "multipart/form-data").prop("encoding", "multipart/form-data") } form.submit(); if (fileInputClones && fileInputClones.length) { options.fileInput.each(function (index, input) { var clone = $(fileInputClones[index]); $(input).prop("name", clone.prop("name")); clone.replaceWith(input) }) } }); form.append(iframe).appendTo(document.body) }, abort: function () { if (iframe) { iframe.unbind("load").prop("src", "javascript".concat(":false;")) } if (form) { form.remove() } } } } }); $.ajaxSetup({ converters: { "iframe text": function (iframe) { return $(iframe[0].body).text() }, "iframe json": function (iframe) { return $.parseJSON($(iframe[0].body).text()) }, "iframe html": function (iframe) { return $(iframe[0].body).html() }, "iframe script": function (iframe) { return $.globalEval($(iframe[0].body).text()) } } }) }));
// The basic File Upload plugin
(function (factory) { if (typeof define === "function" && define.amd) { define(["jquery", "jquery.ui.widget"], factory) } else { factory(window.jQuery) } } (function ($) { $.support.xhrFileUpload = !!(window.XMLHttpRequestUpload && window.FileReader); $.support.xhrFormDataFileUpload = !!window.FormData; $.widget("blueimp.fileupload", { options: { namespace: undefined, dropZone: $(document), fileInput: undefined, replaceFileInput: true, paramName: undefined, singleFileUploads: true, limitMultiFileUploads: undefined, sequentialUploads: false, limitConcurrentUploads: undefined, forceIframeTransport: false, redirect: undefined, redirectParamName: undefined, postMessage: undefined, multipart: true, maxChunkSize: undefined, uploadedBytes: undefined, recalculateProgress: true, formData: function (form) { return form.serializeArray() }, add: function (e, data) { data.submit() }, processData: false, contentType: false, cache: false }, _refreshOptionsList: ["namespace", "dropZone", "fileInput", "multipart", "forceIframeTransport"], _isXHRUpload: function (options) { return !options.forceIframeTransport && ((!options.multipart && $.support.xhrFileUpload) || $.support.xhrFormDataFileUpload) }, _getFormData: function (options) { var formData; if (typeof options.formData === "function") { return options.formData(options.form) } else { if ($.isArray(options.formData)) { return options.formData } else { if (options.formData) { formData = []; $.each(options.formData, function (name, value) { formData.push({ name: name, value: value }) }); return formData } } } return [] }, _getTotal: function (files) { var total = 0; $.each(files, function (index, file) { total += file.size || 1 }); return total }, _onProgress: function (e, data) { if (e.lengthComputable) { var total = data.total || this._getTotal(data.files), loaded = parseInt(e.loaded / e.total * (data.chunkSize || total), 10) + (data.uploadedBytes || 0); this._loaded += loaded - (data.loaded || data.uploadedBytes || 0); data.lengthComputable = true; data.loaded = loaded; data.total = total; this._trigger("progress", e, data); this._trigger("progressall", e, { lengthComputable: true, loaded: this._loaded, total: this._total }) } }, _initProgressListener: function (options) { var that = this, xhr = options.xhr ? options.xhr() : $.ajaxSettings.xhr(); if (xhr.upload) { $(xhr.upload).bind("progress", function (e) { var oe = e.originalEvent; e.lengthComputable = oe.lengthComputable; e.loaded = oe.loaded; e.total = oe.total; that._onProgress(e, options) }); options.xhr = function () { return xhr } } }, _initXHRData: function (options) { var formData, file = options.files[0], multipart = options.multipart || !$.support.xhrFileUpload, paramName = options.paramName[0]; if (!multipart || options.blob) { options.headers = $.extend(options.headers, { "X-File-Name": file.name, "X-File-Type": file.type, "X-File-Size": file.size }); if (!options.blob) { options.contentType = file.type; options.data = file } else { if (!multipart) { options.contentType = "application/octet-stream"; options.data = options.blob } } } if (multipart && $.support.xhrFormDataFileUpload) { if (options.postMessage) { formData = this._getFormData(options); if (options.blob) { formData.push({ name: paramName, value: options.blob }) } else { $.each(options.files, function (index, file) { formData.push({ name: options.paramName[index] || paramName, value: file }) }) } } else { if (options.formData instanceof FormData) { formData = options.formData } else { formData = new FormData(); $.each(this._getFormData(options), function (index, field) { formData.append(field.name, field.value) }) } if (options.blob) { formData.append(paramName, options.blob, file.name) } else { $.each(options.files, function (index, file) { if (file instanceof Blob) { formData.append(options.paramName[index] || paramName, file, file.name) } }) } } options.data = formData } options.blob = null }, _initIframeSettings: function (options) { options.dataType = "iframe " + (options.dataType || ""); options.formData = this._getFormData(options); if (options.redirect && $("<a></a>").prop("href", options.url).prop("host") !== location.host) { options.formData.push({ name: options.redirectParamName || "redirect", value: options.redirect }) } }, _initDataSettings: function (options) { if (this._isXHRUpload(options)) { if (!this._chunkedUpload(options, true)) { if (!options.data) { this._initXHRData(options) } this._initProgressListener(options) } if (options.postMessage) { options.dataType = "postmessage " + (options.dataType || "") } } else { this._initIframeSettings(options, "iframe") } }, _getParamName: function (options) { var fileInput = $(options.fileInput), paramName = options.paramName; if (!paramName) { paramName = []; fileInput.each(function () { var input = $(this), name = input.prop("name") || "files[]", i = (input.prop("files") || [1]).length; while (i) { paramName.push(name); i -= 1 } }); if (!paramName.length) { paramName = [fileInput.prop("name") || "files[]"] } } else { if (!$.isArray(paramName)) { paramName = [paramName] } } return paramName }, _initFormSettings: function (options) { if (!options.form || !options.form.length) { options.form = $(options.fileInput.prop("form")) } options.paramName = this._getParamName(options); if (!options.url) { options.url = options.form.prop("action") || location.href } options.type = (options.type || options.form.prop("method") || "").toUpperCase(); if (options.type !== "POST" && options.type !== "PUT") { options.type = "POST" } }, _getAJAXSettings: function (data) { var options = $.extend({}, this.options, data); this._initFormSettings(options); this._initDataSettings(options); return options }, _enhancePromise: function (promise) { promise.success = promise.done; promise.error = promise.fail; promise.complete = promise.always; return promise }, _getXHRPromise: function (resolveOrReject, context, args) { var dfd = $.Deferred(), promise = dfd.promise(); context = context || this.options.context || promise; if (resolveOrReject === true) { dfd.resolveWith(context, args) } else { if (resolveOrReject === false) { dfd.rejectWith(context, args) } } promise.abort = dfd.promise; return this._enhancePromise(promise) }, _chunkedUpload: function (options, testOnly) { var that = this, file = options.files[0], fs = file.size, ub = options.uploadedBytes = options.uploadedBytes || 0, mcs = options.maxChunkSize || fs, slice = file.webkitSlice || file.mozSlice || file.slice, upload, n, jqXHR, pipe; if (!(this._isXHRUpload(options) && slice && (ub || mcs < fs)) || options.data) { return false } if (testOnly) { return true } if (ub >= fs) { file.error = "uploadedBytes"; return this._getXHRPromise(false, options.context, [null, "error", file.error]) } n = Math.ceil((fs - ub) / mcs); upload = function (i) { if (!i) { return that._getXHRPromise(true, options.context) } return upload(i -= 1).pipe(function () { var o = $.extend({}, options); o.blob = slice.call(file, ub + i * mcs, ub + (i + 1) * mcs); o.chunkSize = o.blob.size; that._initXHRData(o); that._initProgressListener(o); jqXHR = ($.ajax(o) || that._getXHRPromise(false, o.context)).done(function () { if (!o.loaded) { that._onProgress($.Event("progress", { lengthComputable: true, loaded: o.chunkSize, total: o.chunkSize }), o) } options.uploadedBytes = o.uploadedBytes += o.chunkSize }); return jqXHR }) }; pipe = upload(n); pipe.abort = function () { return jqXHR.abort() }; return this._enhancePromise(pipe) }, _beforeSend: function (e, data) { if (this._active === 0) { this._trigger("start") } this._active += 1; this._loaded += data.uploadedBytes || 0; this._total += this._getTotal(data.files) }, _onDone: function (result, textStatus, jqXHR, options) { if (!this._isXHRUpload(options)) { this._onProgress($.Event("progress", { lengthComputable: true, loaded: 1, total: 1 }), options) } options.result = result; options.textStatus = textStatus; options.jqXHR = jqXHR; this._trigger("done", null, options) }, _onFail: function (jqXHR, textStatus, errorThrown, options) { options.jqXHR = jqXHR; options.textStatus = textStatus; options.errorThrown = errorThrown; this._trigger("fail", null, options); if (options.recalculateProgress) { this._loaded -= options.loaded || options.uploadedBytes || 0; this._total -= options.total || this._getTotal(options.files) } }, _onAlways: function (jqXHRorResult, textStatus, jqXHRorError, options) { this._active -= 1; options.textStatus = textStatus; if (jqXHRorError && jqXHRorError.always) { options.jqXHR = jqXHRorError; options.result = jqXHRorResult } else { options.jqXHR = jqXHRorResult; options.errorThrown = jqXHRorError } this._trigger("always", null, options); if (this._active === 0) { this._trigger("stop"); this._loaded = this._total = 0 } }, _onSend: function (e, data) { var that = this, jqXHR, slot, pipe, options = that._getAJAXSettings(data), send = function (resolve, args) { that._sending += 1; jqXHR = jqXHR || ((resolve !== false && that._trigger("send", e, options) !== false && (that._chunkedUpload(options) || $.ajax(options))) || that._getXHRPromise(false, options.context, args)).done(function (result, textStatus, jqXHR) { that._onDone(result, textStatus, jqXHR, options) }).fail(function (jqXHR, textStatus, errorThrown) { that._onFail(jqXHR, textStatus, errorThrown, options) }).always(function (jqXHRorResult, textStatus, jqXHRorError) { that._sending -= 1; that._onAlways(jqXHRorResult, textStatus, jqXHRorError, options); if (options.limitConcurrentUploads && options.limitConcurrentUploads > that._sending) { var nextSlot = that._slots.shift(); while (nextSlot) { if (!nextSlot.isRejected()) { nextSlot.resolve(); break } nextSlot = that._slots.shift() } } }); return jqXHR }; this._beforeSend(e, options); if (this.options.sequentialUploads || (this.options.limitConcurrentUploads && this.options.limitConcurrentUploads <= this._sending)) { if (this.options.limitConcurrentUploads > 1) { slot = $.Deferred(); this._slots.push(slot); pipe = slot.pipe(send) } else { pipe = (this._sequence = this._sequence.pipe(send, send)) } pipe.abort = function () { var args = [undefined, "abort", "abort"]; if (!jqXHR) { if (slot) { slot.rejectWith(args) } return send(false, args) } return jqXHR.abort() }; return this._enhancePromise(pipe) } return send() }, _onAdd: function (e, data) { var that = this, result = true, options = $.extend({}, this.options, data), limit = options.limitMultiFileUploads, paramName = this._getParamName(options), paramNameSet, paramNameSlice, fileSet, i; if (!(options.singleFileUploads || limit) || !this._isXHRUpload(options)) { fileSet = [data.files]; paramNameSet = [paramName] } else { if (!options.singleFileUploads && limit) { fileSet = []; paramNameSet = []; for (i = 0; i < data.files.length; i += limit) { fileSet.push(data.files.slice(i, i + limit)); paramNameSlice = paramName.slice(i, i + limit); if (!paramNameSlice.length) { paramNameSlice = paramName } paramNameSet.push(paramNameSlice) } } else { paramNameSet = paramName } } data.originalFiles = data.files; $.each(fileSet || data.files, function (index, element) { var newData = $.extend({}, data); newData.files = fileSet ? element : [element]; newData.paramName = paramNameSet[index]; newData.submit = function () { newData.jqXHR = this.jqXHR = (that._trigger("submit", e, this) !== false) && that._onSend(e, this); return this.jqXHR }; return (result = that._trigger("add", e, newData)) }); return result }, _normalizeFile: function (index, file) { if (file.name === undefined && file.size === undefined) { file.name = file.fileName; file.size = file.fileSize } }, _replaceFileInput: function (input) { var inputClone = input.clone(true); $("<form></form>").append(inputClone)[0].reset(); input.after(inputClone).detach(); $.cleanData(input.unbind("remove")); this.options.fileInput = this.options.fileInput.map(function (i, el) { if (el === input[0]) { return inputClone[0] } return el }); if (input[0] === this.element[0]) { this.element = inputClone } }, _onChange: function (e) { var that = e.data.fileupload, data = { files: $.each($.makeArray(e.target.files), that._normalizeFile), fileInput: $(e.target), form: $(e.target.form) }; if (!data.files.length) { data.files = [{ name: e.target.value.replace(/^.*\\/, "")}] } if (that.options.replaceFileInput) { that._replaceFileInput(data.fileInput) } if (that._trigger("change", e, data) === false || that._onAdd(e, data) === false) { return false } }, _onPaste: function (e) { var that = e.data.fileupload, cbd = e.originalEvent.clipboardData, items = (cbd && cbd.items) || [], data = { files: [] }; $.each(items, function (index, item) { var file = item.getAsFile && item.getAsFile(); if (file) { data.files.push(file) } }); if (that._trigger("paste", e, data) === false || that._onAdd(e, data) === false) { return false } }, _onDrop: function (e) { var that = e.data.fileupload, dataTransfer = e.dataTransfer = e.originalEvent.dataTransfer, data = { files: $.each($.makeArray(dataTransfer && dataTransfer.files), that._normalizeFile) }; if (that._trigger("drop", e, data) === false || that._onAdd(e, data) === false) { return false } e.preventDefault() }, _onDragOver: function (e) { var that = e.data.fileupload, dataTransfer = e.dataTransfer = e.originalEvent.dataTransfer; if (that._trigger("dragover", e) === false) { return false } if (dataTransfer) { dataTransfer.dropEffect = dataTransfer.effectAllowed = "copy" } e.preventDefault() }, _initEventHandlers: function () { var ns = this.options.namespace; if (this._isXHRUpload(this.options)) { this.options.dropZone.bind("dragover." + ns, { fileupload: this }, this._onDragOver).bind("drop." + ns, { fileupload: this }, this._onDrop).bind("paste." + ns, { fileupload: this }, this._onPaste) } this.options.fileInput.bind("change." + ns, { fileupload: this }, this._onChange) }, _destroyEventHandlers: function () { var ns = this.options.namespace; this.options.dropZone.unbind("dragover." + ns, this._onDragOver).unbind("drop." + ns, this._onDrop).unbind("paste." + ns, this._onPaste); this.options.fileInput.unbind("change." + ns, this._onChange) }, _setOption: function (key, value) { var refresh = $.inArray(key, this._refreshOptionsList) !== -1; if (refresh) { this._destroyEventHandlers() } $.Widget.prototype._setOption.call(this, key, value); if (refresh) { this._initSpecialOptions(); this._initEventHandlers() } }, _initSpecialOptions: function () { var options = this.options; if (options.fileInput === undefined) { options.fileInput = this.element.is("input:file") ? this.element : this.element.find("input:file") } else { if (!(options.fileInput instanceof $)) { options.fileInput = $(options.fileInput) } } if (!(options.dropZone instanceof $)) { options.dropZone = $(options.dropZone) } }, _create: function () { var options = this.options; $.extend(options, $(this.element[0].cloneNode(false)).data()); options.namespace = options.namespace || this.widgetName; this._initSpecialOptions(); this._slots = []; this._sequence = this._getXHRPromise(true); this._sending = this._active = this._loaded = this._total = 0; this._initEventHandlers() }, destroy: function () { this._destroyEventHandlers(); $.Widget.prototype.destroy.call(this) }, enable: function () { $.Widget.prototype.enable.call(this); this._initEventHandlers() }, disable: function () { this._destroyEventHandlers(); $.Widget.prototype.disable.call(this) }, add: function (data) { if (!data || this.options.disabled) { return } data.files = $.each($.makeArray(data.files), this._normalizeFile); this._onAdd(null, data) }, send: function (data) { if (data && !this.options.disabled) { data.files = $.each($.makeArray(data.files), this._normalizeFile); if (data.files.length) { return this._onSend(null, data) } } return this._getXHRPromise(false, data && data.context) } }) }));
// The File Upload file processing plugin
(function (factory) { if (typeof define === "function" && define.amd) { define(["jquery", "load-image", "canvas-to-blob", "./jquery.fileupload"], factory) } else { factory(window.jQuery, window.loadImage) } } (function ($, loadImage) { $.widget("blueimpFP.fileupload", $.blueimp.fileupload, { options: { process: [], add: function (e, data) { $(this).fileupload("process", data).done(function () { data.submit() }) } }, processActions: { load: function (data, options) { var that = this, file = data.files[data.index], dfd = $.Deferred(); if (window.HTMLCanvasElement && window.HTMLCanvasElement.prototype.toBlob && ($.type(options.maxFileSize) !== "number" || file.size < options.maxFileSize) && (!options.fileTypes || options.fileTypes.test(file.type))) { loadImage(file, function (canvas) { data.canvas = canvas; dfd.resolveWith(that, [data]) }, { canvas: true }) } else { dfd.rejectWith(that, [data]) } return dfd.promise() }, resize: function (data, options) { if (data.canvas) { var canvas = loadImage.scale(data.canvas, options); if (canvas.width !== data.canvas.width || canvas.height !== data.canvas.height) { data.canvas = canvas; data.processed = true } } return data }, save: function (data, options) { if (!data.canvas || !data.processed) { return data } var that = this, file = data.files[data.index], name = file.name, dfd = $.Deferred(), callback = function (blob) { if (!blob.name) { if (file.type === blob.type) { blob.name = file.name } else { if (file.name) { blob.name = file.name.replace(/\..+$/, "." + blob.type.substr(6)) } } } data.files[data.index] = blob; dfd.resolveWith(that, [data]) }; if (data.canvas.mozGetAsFile) { callback(data.canvas.mozGetAsFile((/^image\/(jpeg|png)$/.test(file.type) && name) || ((name && name.replace(/\..+$/, "")) || "blob") + ".png", file.type)) } else { data.canvas.toBlob(callback, file.type) } return dfd.promise() } }, _processFile: function (files, index, options) { var that = this, dfd = $.Deferred().resolveWith(that, [{ files: files, index: index}]), chain = dfd.promise(); that._processing += 1; $.each(options.process, function (i, settings) { chain = chain.pipe(function (data) { return that.processActions[settings.action].call(this, data, settings) }) }); chain.always(function () { that._processing -= 1; if (that._processing === 0) { that.element.removeClass("fileupload-processing") } }); if (that._processing === 1) { that.element.addClass("fileupload-processing") } return chain }, process: function (data) { var that = this, options = $.extend({}, this.options, data); if (options.process && options.process.length && this._isXHRUpload(options)) { $.each(data.files, function (index, file) { that._processingQueue = that._processingQueue.pipe(function () { var dfd = $.Deferred(); that._processFile(data.files, index, options).always(function () { dfd.resolveWith(that) }); return dfd.promise() }) }) } return this._processingQueue }, _create: function () { $.blueimp.fileupload.prototype._create.call(this); this._processing = 0; this._processingQueue = $.Deferred().resolveWith(this).promise() } }) }));
// The File Upload user interface plugin
(function (factory) { if (typeof define === "function" && define.amd) { define(["jquery", "tmpl", "load-image", "./jquery.fileupload-fp"], factory) } else { factory(window.jQuery, window.tmpl, window.loadImage) } } (function ($, tmpl, loadImage) { var parentWidget = ($.blueimpFP || $.blueimp).fileupload; $.widget("blueimpUI.fileupload", parentWidget, { options: { autoUpload: false, maxNumberOfFiles: undefined, maxFileSize: undefined, minFileSize: undefined, acceptFileTypes: /.+$/i, previewSourceFileTypes: /^image\/(gif|jpeg|png)$/, previewSourceMaxFileSize: 5000000, previewMaxWidth: 80, previewMaxHeight: 80, previewAsCanvas: true, uploadTemplateId: "template-upload", downloadTemplateId: "template-download", filesContainer: undefined, prependFiles: false, dataType: "json", add: function (e, data) { var that = $(this).data("fileupload"), options = that.options, files = data.files; $(this).fileupload("process", data).done(function () { that._adjustMaxNumberOfFiles(-files.length); data.isAdjusted = true; data.files.valid = data.isValidated = that._validate(files); data.context = that._renderUpload(files).data("data", data); options.filesContainer[options.prependFiles ? "prepend" : "append"](data.context); that._renderPreviews(files, data.context); that._forceReflow(data.context); that._transition(data.context).done(function () { if ((that._trigger("added", e, data) !== false) && (options.autoUpload || data.autoUpload) && data.autoUpload !== false && data.isValidated) { data.submit() } }) }) }, send: function (e, data) { var that = $(this).data("fileupload"); if (!data.isValidated) { if (!data.isAdjusted) { that._adjustMaxNumberOfFiles(-data.files.length) } if (!that._validate(data.files)) { return false } } if (data.context && data.dataType && data.dataType.substr(0, 6) === "iframe") { data.context.find(".progress").addClass(!$.support.transition && "progress-animated").find(".bar").css("width", parseInt(100, 10) + "%") } return that._trigger("sent", e, data) }, done: function (e, data) { var that = $(this).data("fileupload"), template, preview; if (data.context) { data.context.each(function (index) { var file = ($.isArray(data.result) && data.result[index]) || { error: "emptyResult" }; if (file.error) { that._adjustMaxNumberOfFiles(1) } that._transition($(this)).done(function () { var node = $(this); template = that._renderDownload([file]).css("height", node.height()).replaceAll(node); that._forceReflow(template); that._transition(template).done(function () { data.context = $(this); that._trigger("completed", e, data) }) }) }) } else { template = that._renderDownload(data.result).appendTo(that.options.filesContainer); that._forceReflow(template); that._transition(template).done(function () { data.context = $(this); that._trigger("completed", e, data) }) } }, fail: function (e, data) { var that = $(this).data("fileupload"), template; that._adjustMaxNumberOfFiles(data.files.length); if (data.context) { data.context.each(function (index) { if (data.errorThrown !== "abort") { var file = data.files[index]; file.error = file.error || data.errorThrown || true; that._transition($(this)).done(function () { var node = $(this); template = that._renderDownload([file]).replaceAll(node); that._forceReflow(template); that._transition(template).done(function () { data.context = $(this); that._trigger("failed", e, data) }) }) } else { that._transition($(this)).done(function () { $(this).remove(); that._trigger("failed", e, data) }) } }) } else { if (data.errorThrown !== "abort") { that._adjustMaxNumberOfFiles(-data.files.length); data.context = that._renderUpload(data.files).appendTo(that.options.filesContainer).data("data", data); that._forceReflow(data.context); that._transition(data.context).done(function () { data.context = $(this); that._trigger("failed", e, data) }) } else { that._trigger("failed", e, data) } } }, progress: function (e, data) { if (data.context) { data.context.find(".progress .bar").css("width", parseInt(data.loaded / data.total * 100, 10) + "%") } }, progressall: function (e, data) { $(this).find(".fileupload-buttonbar .progress .bar").css("width", parseInt(data.loaded / data.total * 100, 10) + "%") }, start: function (e) { var that = $(this).data("fileupload"); that._transition($(this).find(".fileupload-buttonbar .progress")).done(function () { that._trigger("started", e) }) }, stop: function (e) { var that = $(this).data("fileupload"); that._transition($(this).find(".fileupload-buttonbar .progress")).done(function () { $(this).find(".bar").css("width", "0%"); that._trigger("stopped", e) }) }, destroy: function (e, data) { var that = $(this).data("fileupload"); if (data.url) { $.ajax(data) } that._adjustMaxNumberOfFiles(1); that._transition(data.context).done(function () { $(this).remove(); that._trigger("destroyed", e, data) }) } }, _enableDragToDesktop: function () { var link = $(this), url = link.prop("href"), name = link.prop("download"), type = "application/octet-stream"; link.bind("dragstart", function (e) { try { e.originalEvent.dataTransfer.setData("DownloadURL", [type, name, url].join(":")) } catch (err) { } }) }, _adjustMaxNumberOfFiles: function (operand) { if (typeof this.options.maxNumberOfFiles === "number") { this.options.maxNumberOfFiles += operand; if (this.options.maxNumberOfFiles < 1) { this._disableFileInputButton() } else { this._enableFileInputButton() } } }, _formatFileSize: function (bytes) { if (typeof bytes !== "number") { return "" } if (bytes >= 1000000000) { return (bytes / 1000000000).toFixed(2) + " GB" } if (bytes >= 1000000) { return (bytes / 1000000).toFixed(2) + " MB" } return (bytes / 1000).toFixed(2) + " KB" }, _hasError: function (file) { if (file.error) { return file.error } if (this.options.maxNumberOfFiles < 0) { return "maxNumberOfFiles" } if (!(this.options.acceptFileTypes.test(file.type) || this.options.acceptFileTypes.test(file.name))) { return "acceptFileTypes" } if (this.options.maxFileSize && file.size > this.options.maxFileSize) { return "maxFileSize" } if (typeof file.size === "number" && file.size < this.options.minFileSize) { return "minFileSize" } return null }, _validate: function (files) { var that = this, valid = !!files.length; $.each(files, function (index, file) { file.error = that._hasError(file); if (file.error) { valid = false } }); return valid }, _renderTemplate: function (func, files) { if (!func) { return $() } var result = func({ files: files, formatFileSize: this._formatFileSize, options: this.options }); if (result instanceof $) { return result } return $(this.options.templatesContainer).html(result).children() }, _renderPreview: function (file, node) { var that = this, options = this.options, dfd = $.Deferred(); return ((loadImage && loadImage(file, function (img) { node.append(img); that._forceReflow(node); that._transition(node).done(function () { dfd.resolveWith(node) }); if (!$.contains(document.body, node[0])) { dfd.resolveWith(node) } }, { maxWidth: options.previewMaxWidth, maxHeight: options.previewMaxHeight, canvas: options.previewAsCanvas })) || dfd.resolveWith(node)) && dfd }, _renderPreviews: function (files, nodes) { var that = this, options = this.options; nodes.find(".preview span").each(function (index, element) { var file = files[index]; if (options.previewSourceFileTypes.test(file.type) && ($.type(options.previewSourceMaxFileSize) !== "number" || file.size < options.previewSourceMaxFileSize)) { that._processingQueue = that._processingQueue.pipe(function () { var dfd = $.Deferred(); that._renderPreview(file, $(element)).done(function () { dfd.resolveWith(that) }); return dfd.promise() }) } }); return this._processingQueue }, _renderUpload: function (files) { return this._renderTemplate(this.options.uploadTemplate, files) }, _renderDownload: function (files) { return this._renderTemplate(this.options.downloadTemplate, files).find("a[download]").each(this._enableDragToDesktop).end() }, _startHandler: function (e) { e.preventDefault(); var button = $(this), template = button.closest(".template-upload"), data = template.data("data"); if (data && data.submit && !data.jqXHR && data.submit()) { button.prop("disabled", true) } }, _cancelHandler: function (e) { e.preventDefault(); var template = $(this).closest(".template-upload"), data = template.data("data") || {}; if (!data.jqXHR) { data.errorThrown = "abort"; e.data.fileupload._trigger("fail", e, data) } else { data.jqXHR.abort() } }, _deleteHandler: function (e) { e.preventDefault(); var button = $(this); e.data.fileupload._trigger("destroy", e, { context: button.closest(".template-download"), url: button.attr("data-url"), type: button.attr("data-type") || "DELETE", dataType: e.data.fileupload.options.dataType }) }, _forceReflow: function (node) { this._reflow = $.support.transition && node.length && node[0].offsetWidth }, _transition: function (node) { var that = this, dfd = $.Deferred(); if ($.support.transition && node.hasClass("fade")) { node.bind($.support.transition.end, function (e) { if (e.target === node[0]) { node.unbind($.support.transition.end); dfd.resolveWith(node) } }).toggleClass("in") } else { node.toggleClass("in"); dfd.resolveWith(node) } return dfd }, _initButtonBarEventHandlers: function () { var fileUploadButtonBar = this.element.find(".fileupload-buttonbar"), filesList = this.options.filesContainer, ns = this.options.namespace; fileUploadButtonBar.find(".start").bind("click." + ns, function (e) { e.preventDefault(); filesList.find(".start button").click() }); fileUploadButtonBar.find(".cancel").bind("click." + ns, function (e) { e.preventDefault(); filesList.find(".cancel button").click() }); fileUploadButtonBar.find(".delete").bind("click." + ns, function (e) { e.preventDefault(); filesList.find(".delete input:checked").siblings("button").click(); fileUploadButtonBar.find(".toggle").prop("checked", false) }); fileUploadButtonBar.find(".toggle").bind("change." + ns, function (e) { filesList.find(".delete input").prop("checked", $(this).is(":checked")) }) }, _destroyButtonBarEventHandlers: function () { this.element.find(".fileupload-buttonbar button").unbind("click." + this.options.namespace); this.element.find(".fileupload-buttonbar .toggle").unbind("change." + this.options.namespace) }, _initEventHandlers: function () { parentWidget.prototype._initEventHandlers.call(this); var eventData = { fileupload: this }; this.options.filesContainer.delegate(".start button", "click." + this.options.namespace, eventData, this._startHandler).delegate(".cancel button", "click." + this.options.namespace, eventData, this._cancelHandler).delegate(".delete button", "click." + this.options.namespace, eventData, this._deleteHandler); this._initButtonBarEventHandlers() }, _destroyEventHandlers: function () { var options = this.options; this._destroyButtonBarEventHandlers(); options.filesContainer.undelegate(".start button", "click." + options.namespace).undelegate(".cancel button", "click." + options.namespace).undelegate(".delete button", "click." + options.namespace); parentWidget.prototype._destroyEventHandlers.call(this) }, _enableFileInputButton: function () { this.element.find(".fileinput-button input").prop("disabled", false).parent().removeClass("disabled") }, _disableFileInputButton: function () { this.element.find(".fileinput-button input").prop("disabled", true).parent().addClass("disabled") }, _initTemplates: function () { var options = this.options; options.templatesContainer = document.createElement(options.filesContainer.prop("nodeName")); if (tmpl) { if (options.uploadTemplateId) { options.uploadTemplate = tmpl(options.uploadTemplateId) } if (options.downloadTemplateId) { options.downloadTemplate = tmpl(options.downloadTemplateId) } } }, _initFilesContainer: function () { var options = this.options; if (options.filesContainer === undefined) { options.filesContainer = this.element.find(".files") } else { if (!(options.filesContainer instanceof $)) { options.filesContainer = $(options.filesContainer) } } }, _initSpecialOptions: function () { parentWidget.prototype._initSpecialOptions.call(this); this._initFilesContainer(); this._initTemplates() }, _create: function () { parentWidget.prototype._create.call(this); this._refreshOptionsList.push("filesContainer", "uploadTemplateId", "downloadTemplateId"); if (!$.blueimpFP) { this._processingQueue = $.Deferred().resolveWith(this).promise(); this.process = function () { return this._processingQueue } } }, enable: function () { parentWidget.prototype.enable.call(this); this.element.find("input, button").prop("disabled", false); this._enableFileInputButton() }, disable: function () { this.element.find("input, button").prop("disabled", true); this._disableFileInputButton(); parentWidget.prototype.disable.call(this) } }) }));
// The localization script
window.locale = {
    "fileupload": {
        "errors": {
            "maxFileSize": "File is too big",
            "minFileSize": "File is too small",
            "acceptFileTypes": "Filetype not allowed",
            "maxNumberOfFiles": "Max number of files exceeded",
            "uploadedBytes": "Uploaded bytes exceed file size",
            "emptyResult": "Empty file upload result"
        },
        "error": "Error",
        "start": "Start",
        "cancel": "Cancel",
        "destroy": "Delete"
    }
};
// The main application script
$(function () {
    'use strict';

    // Initialize the jQuery File Upload widget:
    $('#fileupload').fileupload();

    $('#fileupload').fileupload('option', {
        maxFileSize: 500000000,
        resizeMaxWidth: 1920,
        resizeMaxHeight: 1200,
        autoUpload: false,
        acceptFileTypes: /(\.|\/)(gif|jpe?g|png)$/i
    }).bind('fileuploaddone', function (e, data) { console.log(arguments); });

});

